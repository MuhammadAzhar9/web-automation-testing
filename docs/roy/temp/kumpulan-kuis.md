You completed Knowledge check 1.1
Your score
100%


Retake Quiz

Continue
You answered 4 out of 4 questions correctly

1.
What does BDD stand for?

BDD is an approach that collaboratively specifies the system's desired behaviour. Each time a piece of behaviour is agreed, we use that specification to "drive" the development of the code that will implement that behaviour.

2.
What are the three practices of BDD, and in what order do you apply them to a story?

We start by collaboratively discovering the scope of the behaviour required by the story. Once we have agreed on that behaviour, we formulate the specification in business-readable language. Finally, we automate the formulated specification to verify that the system actually behaves as expected.

3.
How are Cucumber and BDD related?

Cucumber is a tool that understands your documentation and turns it into automated tests.

BDD is a collaborative approach, made up of three practices. BDD practitioners may use Cucumber to automate their documentation.

4.
What is special about “living documentation”?

We call it "Living Documentation" because the documentation automatically tells us when it goes out of sync with the behaviour of the application. That's what special about it.

You might well review it as part of your definition of done, but that would also be true of any kind of specification document you wrote, even if it wasn't automatically validated.

It's not generated by automated tests - you still have to write it! The automated tests just tell you whether what you wrote is true or not.

You might well have a change control process for it - we encourage you to keep it in source control with the code it describes - but again that's nothing special. You could have a wonderfully transparent change control process for a Word document and it could still be completely out of date and wrong.


---

You completed Knowledge check 1.2
Your score
100%


Retake Quiz

Continue
You answered 3 out of 3 questions correctly

1.
BDD practitioners prefer comprehensive documentation over collaboration

BDD is a collaborative activity. Living documentation is a secondary, valuable, output of applying BDD practices.

2.
What’s the relationship between BDD and agile?

BDD is a collection of practices that build upon agile ways of working, helping teams succeed. For these practices to deliver value, you'll need to be working in an agile way.

3.
What is it about User Stories that helps a team to do BDD?

User stories were created to be "placeholders for a conversation." They allow us to defer detailed analysis until we're confident that the behaviour they describe actually needs to be developed.

---

You completed Knowledge check 1.3
Your score
100%


Retake Quiz

Continue
You answered 3 out of 3 questions correctly

1.
Why do we call it “Three Amigos”?

The goal of a three amigos meeting is to ensure that the team fully understand the scope of the story being discussed. For this to be effective, we need to have at least three different perspectives represented at the meeting.

More than three people might attend a three amigos meeting, because:

some stories are broad enough to require the input of more than three perspectives
more than one representative of each perspective may attend
2.
Who are the three amigos?

The essential three perspectives required are:

customer / business perspective - usually provided by the Product Owner
development perspective - usually provided by a Developer
test perspective - usually provided by a Tester
3.
The group discovered a new business rule during the meeting. Why?

The whole purpose of the three amigos meeting is to discover things about the story that weren't previously obvious. We should expect to learn new things during a three amigos meeting.


---

You completed Knowledge check 1.4
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
Why are questions a valuable output from a discovery session?

We want to discover our areas of ignorance before we start developing the next piece of functionality. If we still have unanswered questions about a piece of functionality, it's unlikely that we're in a position to start working on it.

Before the discovery workshop, the question hadn't been asked. That means it was an unknown unknown - it was something that we were completely unaware of. Now that we have asked the question, it is a known unknown - we are aware that it is an area that we need to learn more about.

Having discovered the question, the team now has a concrete area to investigate, learning more about the problem they're being asked to solve.

2.
Why are testing skills valuable during discovery?

The test perspective is essential during the discovery process. It allows us to ask difficult "what if " style questions that ensure that we have thought about the story in detail. The team use concrete examples to test their understanding of what they're being asked to deliver, while also testing the product owner's understanding of the functionality they're asking for.

--- 
You completed Knowledge check 1.5
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
What is Gherkin?

Gherkin is a simple syntax that allows teams to write business readable, executable specifications. 

Some of the Gherkin keywords are Given, When, and Then, but not all text that uses these words is Gherkin.

Gherkin is understood by a large number of tools, notably Cucumber and Specflow, that effectively turn the specification into automated tests.

2.
What’s the relationship between a scenario and an example?

During three amigos the team uses concrete examples to ensure that they have a shared understanding of the functionality they're about to develop. Those concrete examples are formulated into Gherkin scenarios.

So, each scenario is an example.

Scenario and Example are both keywords in Gherkin.

---

Skenario\
Shouty is a social network that allows people who are physically close to communicate, just like people have always communicated with their voices. In the real world you can talk to someone in the same room, or across the street. Or even 100 m away from you in a park - if you shout.

That’s Shouty. What you say on this social network can only be “heard” by people who are nearby.

Let’s start with a very basic example of Shouty’s behaviour. Something we might have discussed in a three amigos meeting:

Sean the shouter shouts "free bagels at Sean’s" and Lucy the listener who happens to be stood across the street from his store, 15 metres away, hears him. She walks into Sean’s Coffee and takes advantage of the offer.

We can translate this into a Gherkin scenario so that Cucumber can run it. Here’s how that would look.

You can see there are four special keywords being used here. Scenario just tells Cucumber we’re about to describe an example that it can execute. Then you see the lines beginning with Given, When and Then.

Given is the context for the scenario. We’re putting the system into a specific state, ready for the scenario to unfold.

When is an action. Something that happens to the system that will cause something else to happen: an outcome.

Then is the outcome. It’s the behaviour we expect from the system when this action happens in this context.

You’ll notice we’ve omitted from our outcome anything about Lucy walking into Sean’s store and making a purchase. Remember, Gherkin is supposed to describe the behaviour of the system, so it would be distracting to have it in our scenario.

Each scenario has these three ingredients: a context, an action, and one or more outcomes.

Together, they describe one single aspect of the behaviour of the system. An example.

Now that we’ve translated our example into Gherkin, we can automate it!

You completed Knowledge check 2.1
Your score
100%


Retake Quiz

Continue
You answered 4 out of 4 questions correctly

1.
What’s an advantage of using Gherkin to express our examples in BDD?

Gherkin is just one way of expressing examples of how you want your system to behave. The advantage of using this particular format is that you can use Cucumber to test them for you, making them into Living Documentation.

2.
Which of these are Gherkin keywords?

We've introduced four Gherkin keywords so far: 

Scenario tells Cucumber we’re about to describe an example that it can execute.
Given, When and Then identify the steps of the scenario.
There are a few other keywords which will be introduced later in the course.

3.
The Gherkin keywords Given, When and Then, allow us to express three different components of a scenario.

Which of these statements correctly describes how each of these keywords should be used?

Given is the context for the scenario. We’re putting the system into a specific state, ready for the scenario to unfold.

When is an action. Something that happens to the system that will cause something else to happen: an outcome.

Then is the outcome. It’s the behaviour we expect from the system when this action happens in this context.

4.
Why did our scenario not mention anything about Lucy walking into Sean’s store and making a purchase?

Behaviour-Driven Development practitioners definitely do care about business goals, but when we're writing the Scenario part of our Gherkin, we need to focus on the observable, testable behaviour of the system we're building.



Later in the course we'll show you how you can use other parts of Gherkin documents to add other relevant details, like business goals, to make great executable specifications.

---

For instructions on enabling Cucumber in IntelliJ visit https://www.jetbrains.com/help/idea/enabling-cucumber-support-in-project.html”

The easiest way to get started with Cucumber for Java is to use a template project with a build script that sets everything up correctly.

You can download this template project from GitHub. Open your web browser and go to the “Cucumber Java Skeleton” project on GitHub.

If you’re comfortable with Git you can just clone the project.

If you’re new to Git, don’t worry, we’ll download a zip file instead. Click Releases, then download the most recent zip file that starts with a “v”.

On Windows, extract the zip file by double clicking on it. -Or if you’re on OS ten or Linux, extract it with the unzip command.

After extracting the zip file, we’ll rename the directory to “shouty”.

In your shell, cd into the shouty directory.

The template project contains Maven and Ant build scripts that makes it easier to get started with Cucumber for Java.

We’ll be using Maven, so if you haven’t installed that already, now is a good time to do that.

Let’s take a look at what else is in this project.

There is a main directory for our application code, and a test directory for our test code. Let’s remove some of the files that come with the project.

Remove Belly.java, StepDefinitions.java and belly.feature.

Now we have a bare bones project. We’ll be building it from the ground up so you can see what is going on.

Before we open the project in our IDE we are going to modify the name of the application.

Open pom.xml and change the group ID, artifact ID and name.

We are ready to start coding! We are going to use IntelliJ IDEA Community Edition because it has really nice Cucumber integration built-in. If you prefer to use a different IDE such as Eclipse, that is fine too.

To open the project in InteliJ, just open the pom.xml file.

Before we create any files, let’s rename the package from skeleton to shouty. In InteliJ you can rename it via the Refactor menu.

Now we’re ready to create our first feature file.

You completed Knowledge check 2.2
Your score
100%


Retake Quiz

Continue
You answered 1 out of 1 questions correctly

1.
What does it mean when Cucumber says a step is Undefined?

Each line in a Scenario that begins with one of the Given / When / Then keywords is called a step.

When Cucumber tells us that a step is undefined, that means it doesn't know what we want it to do in order to automate that step. We have to tell Cucumber what to do by providing step definitions.

We'll learn about step definitions in the next lesson.

---

To get the code for this chapter and follow along, visit https://github.com/cucumber-school/student/

Let’s create our first feature file. Call the file hear_shout.feature

All feature files start with the keyword Feature: followed by a name. It’s a good convention to give it a name that matches the file name.

Now let’s write out our first scenario.

Now that we have a scenario it’s time to run it!

Switch back to the command prompt and run:

Maven will now download Cucumber, compile your code and tell Cucumber to run your feature file.

You’ll see that Cucumber has found our feature file and read it back to us. We can see a summary of the results at the bottom - 3 steps, one scenario - all undefined.

Let’s run the scenario again from inside InteliJ. Select the feature file and choose Run from the context menu. This will give you similar output.

Undefined means Cucumber doesn’t know what to do for any of the three steps we wrote in our Gherkin scenario. It needs us to provide some step definitions.

Step definitions translate from the plain language you use in Gherkin into Java code. We write a Java method, then annotate it with a pattern.

When cucumber runs a step, it looks for a step definition with a matching pattern. If it finds one, then it executes the method.

If it doesn’t find one… well, you’ve just seen what happens. Cucumber helpfully prints out some code snippets that we can use as a basis for new step definitions. Let’s copy those.

We’ll create a new class in the shouty package where we’ll paste those snippets. Make sure you create it under test and not main.

Now InteliJ is complaining that there are some unknown symbols. We need to add some import statements! Pressing ALT-ENTER will do that for us.

Let’s return to the scenario and run it again.

There is a small bug in InteliJ’s Cucumber integration. Sometimes it doesn’t tell Cucumber where to find step definitions. This is easy to work around. Just edit the run configuration and make sure the Glue field contains the value of your package.

Now we can run it again.

This time the output is a little different.

We now have a pending step and two skipped ones.

This means Cucumber found all our step definitions, and executed the first one. But that first step definition throws a PendingException, which causes Cucumber to stop, skip the rest of the steps, and mark the scenario as pending.

Now that we’ve wired up our step definitions to the Gherkin steps, it’s almost time to start working on our solution. First though, let’s tidy up the generated code.

We’ll rename the int parameter to something that better reflects its meaning. We’ll call it distance.

We can print it to the terminal to see what’s happening.

If we run it again, we can see the number 15 pop up in the output.

Notice that the number 15 does not appear anywhere in our code. The value is automatically passed from the Gherkin step to the step definition. If you’re curious, that’s the {int} in the step definition pattern or cucumber expression. We’ll explain these patterns in detail in a future lesson.

You completed Knowledge check 2.3
Your score
100%


Retake Quiz

Continue
You answered 4 out of 4 questions correctly

1.
What do step definitions do?

Step definitions are Java methods that actually do what's described in each step of a Gherkin scenario.

When it tries to run each step of a scenario, Cucumber will search for a step definition that matches. If there's a matching step definition, it will call the method to run it.



2.
What does it mean when Cucumber says a step is Pending

Cucumber tells us that a step (and by inference the Scenario that contains it) is Pending when the automation code throws a PendingException.

The PendingException is a special type of exception provided by Cucumber to allow the development team to signal that automation for a step is a work in progress. This makes it possible to tell the difference between steps that aren't finished yet and steps that are failing due to a defect in the system.

For example, when we run our tests in a Continuous Integration (CI) environment, we can choose to ignore pending scenarios.

3.
Which of the following might you want to consider when using a snippet generated by Cucumber?

When Cucumber generates a snippet, it has no idea of the business context of the undefined step. The implementation that Cucumber generates will definitely not automate what's been written in your Gherkin - that's up to you! 

Also, the name of the method and the parameters are just placeholders. It's the job of the person writing the code to rename the method and parameters to reflect the business domain.

4.
What’s the next step in BDD after we’ve pasted in the step definition snippet and seen it fail with a pending status?

If you read the comment in the generated snippet, Cucumber is telling you to "write the code you wish you had".

You need your step definition to call your application and do whatever the Gherkin step describes. In the case of our first step here, we want to tell the system that there are two people in certain locations.

We can use the act of fleshing out the body of our step definition as an opportunity to do some software design. We can think about what we want the interface to our system to look like, from the point of view of someone who needs to interact with it. Should we interact with it through the User Interface, or make a call to the programmer API directly? How would we like that interface to work?

We can do all of this without writing any implementation yet.

This is known as "outside-in" development. It helps us to ensure that when we do come to implementing our solution, we're implementing it based on real needs.


---

You completed Knowledge check 2.4
Your score
100%


Retake Quiz

Continue
You answered 4 out of 4 questions correctly

1.
Why should we always make sure that we see a scenario fail before we make it pass?

Behaviour-driven development follows the same process as test-driven development, which is sometimes described as red-green-refactor.

red - write a scenario/test and see it fail
green - make it pass (as simply as possible)
refactor - improve your code, while keeping all the tests/scenarios green
It's surprisingly easy to write scenarios and step definitions that don't do anything. It's the transition from red to green that gives us confidence that the scenario and the implementation actually do what we expect.

If a scenario passes as soon as we write it, that means that either it's not doing what we think it should or the behaviour that it describes has already been implemented. In that case, we're not developing using behaviour-driven development.

2.
Why did we change to use an instance variable for storing each Person?

In Cucumber, one of the ways to access the same instance of an object from different step definition methods, is to store it on an instance variable.

3.
How did we avoid having to mention the detail of the text Sean had shouted in our When and Then steps?

When you need to assert for a specific value coming out of your system in a Then step, you can use an instance variable to store it where it goes into the system (in a Given or When) step. This means you can avoid duplicating the value in multiple places in your code.

4.
What flow should we follow when making a scenario pass?

Our goal at this stage is to get to a failing test, where the only thing left to do to make it pass is make changes to the implementation of the app itself.

On an existing system, we might not need to create so much new code to get to this goal, but we might need to make some changes to how we call the system. This gives us an opportunity to do some lightweight domain modelling.

It may not compile first-time, so we implement the bare-bones of our solution until it does.

We use the scenarios to guide us in our implementation.


---


You completed Knowledge check 2.5
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
Why is our naive implementation of Person.getMessagesHeard, with a hard-coded message, OK in BDD?

Our naive implementation of getMessagesHeard is rubbish, but it makes our test pass. Here are some advantages of taking a short-cut like this:

We've done a quick test of the proposed structure of our code without getting bogged down thinking about the logic.
We're teaching outselves a mindset of finding simple solutions that are good enough for now.
It encourages us not to think of our solution as fixed, and therefore to write code that can easily be changed.
It's so bad, it makes it obvious that we need to think about our test cases to find cases that will cover the problem space more fully.
2.
Which stage of this diagram are we at as the video ends?

The last thing we did in the video was to write a new scenario in which Sean shouted "free coffee". Then we ran Cucumber and watched the new scenario fail.

---

You completed Knowledge check 3.1
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
Which of the following statements are true?

A step definition is a piece of code that is called by Cucumber in response to a step in a scenario. You can write any code you like inside a step definition, but we've found it easier to maintain if we keep them short. This leads to step definitions calling dedicated automation code to perform concrete actions against the system under construction. That automation code can manipulate the user interface, make a REST call, or drive the domain model directly.

2.
Which of the following statements are true?

Regular Expressions are a powerful tool that have been used in computer science for many decades. They can be hard understand and maintain, so the Cucumber team created a simplified mechanism, called Cucumber Expressions. However, Cucumber remains backwards compatible, so you can use both Regular Expressions and Cucumber Expressions with modern releases of Cucumber.

---

You completed Knowledge check 3.4
Your score
100%


Retake Quiz

Continue
You answered 3 out of 3 questions correctly

1.
How can you express in a Cucumber Expression that matching some text is optional?

Any text in a Cucumber Expression that is surrounded by parentheses `()` is considered optional.

2.
What does a slash `/` separating words mean in a Cucumber Expression?
Words in a Cucumber Expression that are separated by a slash `/` are considered alternates. There must be no whitespace between the word and the slash.

3.
Which of the following Cucumber Expressions would match both "Given it weighed 3 grammes" and "Given it weighed 1 gramme"?

Any text surrounded by parentheses `()` is considered optional.

Any words separated by a slash `/` are considered to be alternates. 

You can find full documentation about Cucumber Expressions at https://cucumber.io/docs/cucumber/cucumber-expressions

---

You completed Knowledge check 4.1
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
Which aspects of Cucumber help bridge the communication gap between business domain experts and development teams?


The feature files that Cucumber understands are written using Gherkin, so that you can create scenarios that utilise your own domain language, so that they can be read and understood by everyone involved in specifying and delivering your software.

2.
How do Cucumber feature files differ from more traditional automated tests?
BDD is the collaborative approach to developing software that Cucumber was created to support. Although Cucumber scenarios do act as tests when they are automated, this is not their primary purpose. Their primary purpose is to provide a single, shared specification, written in the domain language of your business — facilitating collaboration, feedback, and reliable documentation. The primary purpose of traditional automated tests, on the other hand, is to check that the software behaves as expected.

---

You completed Knowledge check 4.1
Your score
100%


Retake Quiz

Continue
You answered 2 out of 2 questions correctly

1.
Which aspects of Cucumber help bridge the communication gap between business domain experts and development teams?


The feature files that Cucumber understands are written using Gherkin, so that you can create scenarios that utilise your own domain language, so that they can be read and understood by everyone involved in specifying and delivering your software.

2.
How do Cucumber feature files differ from more traditional automated tests?
BDD is the collaborative approach to developing software that Cucumber was created to support. Although Cucumber scenarios do act as tests when they are automated, this is not their primary purpose. Their primary purpose is to provide a single, shared specification, written in the domain language of your business — facilitating collaboration, feedback, and reliable documentation. The primary purpose of traditional automated tests, on the other hand, is to check that the software behaves as expected.

---

You completed Knowledge check 6.2
Your score
100%


Retake Quiz

Continue
You answered 1 out of 1 questions correctly

1.
Which of the tag expressions below would cause the scenario "Two" to be included in a Cucumber run based on this feature file (steps omitted): 
@MVP Feature: My feature

Rule: rule A
  Scenario: One
@smoke
@slow @regression-pack
Scenario: Two
@regression-pack
Scenario: Three
Tags are inherited from the enclosing scope, so a Scenario inherits tags from the Feature. At present Rules cannot be tagged, although we expect this to be fixed in the near future, at which point tags will be inherited like this: Feature→Rule→Scenario.

Tags are case-sensitive, so @SLOW does not match @slow.

Tag expressions can be on the same line and on consecutive lines.

Tag expressions implement the boolean operators: and, not, or.

---

You completed Knowledge check 6.4
Your score
100%


Retake Quiz

Continue
You answered 3 out of 3 questions correctly

1.
Which of the following plugins ship with Cucumber? 
Cucumber ships with lots of plugins. If the plugin that you want does not exist yet you can create your own or you can post-process the output of one of the standard plugins (JSON is often a starting point).

A newer plugin (that is out of scope for this course) is the message plugin. Internally, Cucumber generates messages that are used by the other plugins to create their output. The message plugin outputs these messages directly.

2.
How many plugins can output to the console in any run of Cucumber?
So that the output remains easy to read, no more than one plugin is allowed to write to the console in any given run of Cucumber. You may choose to write the output of every plugin to file

3.
What does the rerun formatter do?
The rerun formatter keeps track of the feature file and line number of every scenario that fails. This information is output in a feature file/line number format that can be saved to file. When provided to Cucumber as input (with the file name preceded by @), the identified scenarios will be run.

---

You completed Knowledge check 6.5
Your score
100%


Retake Quiz

Continue
You answered 4 out of 4 questions correctly

1.
Why did the Cucumber team create Cucumber Reports?
The output from running Cucumber forms the basis of a system’s "living documentation". Before the existence of Cucumber Reports each team/organisation had to implement their own mechanism for sharing the living documentation, but now it’s as simple as asking Cucumber to publish it

2.
How does the output from the HTML formatter differ from that displayed by Cucumber Reports?
The same underlying library generates the output for both Cucumber Reports and the HTML formatter. Cucumber Reports also displays some extra information about that run of Cucumber, summarising the execution context and scenario outcomes.

3.
What extra information can be published by Cucumber Reports? 
Cucumber Reports always publishes:
* High level statistics of scenarios run and their status
* Elapsed time since the report was generated
* The time it took to run the scenarios and generate the report
* Operating system version
* Language version used for stepdefs
* Cucumber version

If Cucumber Reports was run by a supported CI tool, it also publishes: * CI tool version * Identifier (SHA) of the last commit

4.
What happens to reports that are not associated with a "publish token"
Reports that are not associated with a publish token will be deleted approximately 24 hours after being published. Once published, a report can be associated with a publish token, which will then preserve the report until it is explicitly deleted.

For more details on publish tokens, authentication, and association with Github repositories, see reports.cucumber.io

---
